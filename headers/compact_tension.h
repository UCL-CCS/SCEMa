namespace HMM {

template <int dim>
class CompactTension: public ProblemType<dim>
{
public:
	CompactTension (boost::property_tree::ptree input)
{
		input_config = input;
		velocity = input_config.get<double>("problem type.velocity");

		// This compact tension has been progrmamed to work with a specific mesh
		// generated by this code:
		// https://github.com/mkraska/CalculiX-Examples/tree/master/Linear/Crack1
		calculi_B = input_config.get<double>("continuum mesh.input.calculi_B");
		calculi_a = input_config.get<double>("continuum mesh.input.calculi_a");
		calculi_t = input_config.get<double>("continuum mesh.input.calculi_t");
}

	void make_grid(parallel::shared::Triangulation<dim> &triangulation)
	{
		std::string mesh_input_style;
		mesh_input_style = input_config.get<std::string>("continuum mesh.input.style");

		// does input styple contain "file"
		if (mesh_input_style.find("file") != std::string::npos){
			this-> import_mesh(triangulation, input_config);
		}
		// verify dimensions of the mesh compared to inputs variable provided
	}

	void define_boundary_conditions(DoFHandler<dim> &dof_handler)
	{
		typename DoFHandler<dim>::active_cell_iterator cell;

		for (cell = dof_handler.begin_active(); cell != dof_handler.end(); ++cell) {
			double eps = cell->minimum_vertex_distance();
			double delta = eps / 10.0;
			for (uint32_t face = 0; face < GeometryInfo<3>::faces_per_cell; ++face){
				for (uint32_t vert = 0; vert < GeometryInfo<3>::vertices_per_face; ++vert) {

					// Point coords
					double vertex_x = cell->face(face)->vertex(vert)(0);
					double vertex_y = cell->face(face)->vertex(vert)(1);
					double vertex_z = cell->face(face)->vertex(vert)(2);

					// is vertex at base
					if ( abs(vertex_y-0.0) < delta ){
						// allow to move in x and z, fix y
						fixed_vertices.push_back( cell->face(face)->vertex_dof_index(vert, 1) );
					}

					// is vertex on middle plane
					if ( abs(vertex_z-0.0) < delta){
						// allow to move in x and y, fix z
						fixed_vertices.push_back( cell->face(face)->vertex_dof_index(vert, 2) );
					}

					// is vertex in top inner face of hole

					//compute distance to centre of hole
					double bb = calculi_B;
					double aa = calculi_a;
					double ww = 2.0*bb;
					double gg = 1.25*ww;
					double hh = 1.20*ww;
					double tt = calculi_t;
					double ss = 0.55*ww;
					double dd = 0.25*ww;

					double circle_centre_x = ww;
					double circle_centre_y = ss / 2.0;

					double dist_circle_centre = sqrt((vertex_x - circle_centre_x)*
							(vertex_x - circle_centre_x) +
							(vertex_y - circle_centre_y)*
							(vertex_y - circle_centre_y));
					if (abs(dist_circle_centre - dd/2.) < delta &&
							vertex_y > circle_centre_y ) {
						loaded_vertices.push_back( cell->face(face)->vertex_dof_index(vert, 1) );
					}
				}
			}
		}
	}

	std::map<types::global_dof_index,double> set_boundary_conditions(uint32_t timestep, double dt)
					{
		// define accelerations of boundary verticies
		std::map<types::global_dof_index, double> boundary_values;
		types::global_dof_index vert;

		// fixed verticies have acceleration 0
		for (uint32_t i=0; i<fixed_vertices.size(); i++){
			vert = fixed_vertices[i];
			boundary_values.insert( std::pair<types::global_dof_index,double> (vert, 0.0) );
		}

		// apply constant velocity
		// need to pass FE solver the velocity increment
		// first step
		double acceleration;
		if (timestep == 1){
			acceleration = velocity / dt;
		}
		else {
			acceleration = 0;
		}

		for (uint32_t i=0; i<loaded_vertices.size(); i++){
			vert = loaded_vertices[i];
			boundary_values.insert( std::pair<types::global_dof_index,double> (vert, acceleration) );
		}

		return boundary_values;
					}

	std::map<types::global_dof_index,double> boundary_conditions_to_zero(uint32_t timestep)
					{
		std::map<types::global_dof_index, double> boundary_values;
		uint32_t vert;

		for (uint32_t i=0; i<fixed_vertices.size(); i++){
			vert = fixed_vertices[i];
			boundary_values.insert( std::pair<types::global_dof_index,double> (vert, 0.0) );
		}

		for (uint32_t i=0; i<loaded_vertices.size(); i++){
			vert = loaded_vertices[i];
			boundary_values.insert( std::pair<types::global_dof_index,double> (vert, 0.0) );
		}

		return boundary_values;
					}

	bool is_vertex_loaded(int index)
	{
		bool vertex_loaded = false;
		if (std::find(loaded_vertices.begin(), loaded_vertices.end(), index) != loaded_vertices.end())
			vertex_loaded = true;

        return vertex_loaded;
	}

private:
	boost::property_tree::ptree input_config;
	MeshDimensions							mesh;

	std::vector<uint32_t>			fixed_vertices;
	std::vector<uint32_t>			loaded_vertices;

	double velocity;
	double calculi_B;
	double calculi_a;
	double calculi_t;
};
}
